<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F01%2F21%2Fajax%E5%92%8Cjs%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[Ajax Ajax的全称 Asynchronous javascript and XML 异步的javascript和xml,他使用客户端脚本和web服务器交换数据，使得不打断交互流程进行重新加载，ajax刚出现的使用使用的数据格式是xml,后来json数据格式替代了xml。 使用AjaxAjax的核心对象是XMLHttpRequest,目前所有浏览器都支持，只是在在IE5、IE6中的写法不一样。 123456789101112131415161718192021222324252627282930313233343536//步骤1：创建XMLHttpRequest对象function createXHR()&#123; if(window.XMLHttpRequest)&#123; return new XMLHttpRequest(); &#125;else&#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125;&#125;//可以简写如下var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");//步骤2： XMLHttpRequest.open();xhr.open("method"，"url",boolean);// method 指代请求方法// url 指代请求地址// boolean 指代是否异步 true代表异步 false代表同步//步骤3 监听请求状态xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123; if(xhr.status == 200)&#123; //此处写处理函数 //xhr.responseText 是请求返回的数据 dealResult(xhr.responseText); &#125; &#125;&#125;// 步骤4 XMLHttpRequest.send(argument); 发送请求// 如果 请求方式为 个get 参数可以为空 建议最好写做null// 请求方式为post的时候 参数为 发送的请求参数键值对形式的字符串 中文字节要进行转码xhr.send(null); 使用Ajax的步骤是固定的，只是个别参数不同。所以我们可以把这些步骤封装成一个函数，方便我们下次直接调用。 1234567891011121314151617181920212223242526// 封装在一个函数里 名字叫做MyAjaxfunction MyAjax(method,url,data,success,failed)&#123; // 参数1 ：请求方式 ，参数2： 请求地址 ， 参数3：要传递的数据（参数），参数4：请求成功后的处理函数，参数5：请求失败后的处理程序 // 先把method 转换成大写 method = method.touppercase(); var xhr = window.XMLHttpRequest() ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"); // 判断求情方式 ，确定请求地址和参数 if(method == "GET") url = url +"?"+ data; xhr.open(method,url,true); xhr.onreadystatechange = fnction()&#123; if(xhr.readystate == 4 )&#123; if(xhr.status == 200 )&#123; success(xhr.responseText); // 失败时候的方法这里没有写 &#125; &#125; &#125; if(method == "GET")&#123; xhr.send(null); &#125;else&#123; xhr.send(data); &#125;&#125; 同源策略3.1 同源策略是网景公司提出的一个著名安全策略1，协议相同，2，域名相同，3，端口号相同。如果两个网页不同源，是不可以互相访问cookie的。3.2 同源策略的目的， 是为了保证用户的信息安全，防止恶意的窃取数据。3.3 同源策略的限制范围 ： 1，cookie，localstorage和indexDB 无法读取。2，DOM无法获取。3，ajax请求不能发送。 Ajax 规避同源策略 4.1 使用jsonp规避同源jsonp是服务器与客户端跨源通信的常用方法。优点：简单实用，老式浏览器全都支持。缺点：只能使用get请求。基本思想是：网页通过动态的添加一个script标签，向服务器请求json数据，服务器收到请求后，将数据放在指定名字的回调函数里传回来。 12345678910111213141516//函数功能：添加script标签。 参数表示AJAX要请求的地址(一个外部的网页)。function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;//请求参数中添加一个callback参数，用来指定回调函数的名字，这对于JSONP是必须的。window.onload = function () &#123; addScriptTag('http://localhost:8020?callback=foo');&#125;//回调函数。 一旦响应成功，会执行该方法function foo(data) &#123; alert(data); console.log(data);&#125;; 动画 动画有两种实现方式 通过javascript控制css样式 直接使用css提供的动画 javascript中的动画javascript 动画常用的API setTimeout(); setInterval(); requestAnimationFrame() .前两种我们应该都很熟悉，所以主要看第三种 requestAnimationFrame(回调函数)。调用requestAnimationFrame后，它会要求浏览器根据自己的频率进行一次重绘，它接收一个回调函数作为参数，在即将开始的浏览器重绘时，会调用这个函数，并会给这个函数传入调用回调函数时的时间作为参数。由于requestAnimationFrame的功效只是一次性的，所以若想达到动画效果，则必须连续不断的调用requestAnimationFrame，就像我们使用setTimeout来实现动画所做的那样。requestAnimationFrame函数会返回一个资源标识符，可以把它作为参数传入cancelAnimationFrame函数来取消requestAnimationFrame的回调。 123456789101112&lt;script type="text/javascript"&gt; var id； function step() &#123; var temp = div.offsetLeft + 2; div.style.left = temp + "px"; //和setTimeout一样，要手动调用才能实现连续动画。 id = window.requestAnimationFrame(step); //返回值是一个id，可以通过这个id来取消 &#125; id = window.requestAnimationFrame(step); //取消回调函数 window.cancelAnimationFrame();&lt;/script&gt; 使用问题：由于javascript是单线程的，有时候堵塞或者一些其他原因会造成这种动画的失帧等一系列问题，要避免这种问题，我们应该把动画与时间关联起来 123456789function startAnimation() &#123; var startTime = Date.now(); requestAnimationFrame(function change() &#123; var current = Date.now() - startTime; console.log("动画已执行时间" + current); requestAnimationFrame(change); &#125;);&#125;startAnimation(); 动画通常情况下有终止时间，如果是循环动画，我们也可以看做特殊的——当动画达到终止时间之后，重新开始动画。因此，我们可以将动画时间归一表示 12345678910111213141516171819202122//duration 是动画执行时间 isLoop是否为循环执行。function startAnimation(duration, isLoop)&#123; var startTime = Date.now(); requestAnimationFrame(function change()&#123; // 动画已经用去的时间占总时间的比值 var p = (Date.now() - startTime) / duration; if(p &gt;= 1.0)&#123; if(isLoop)&#123; // 如果是循环执行，则开启下一个循环周期。并且把开始时间改成上个周期的结束时间 startTime += duration; p -= 1.0; //动画进度初始化 &#125;else&#123; p = 1.0; //如果不是循环，则把时间进度至为 1.0 表示动画执行结束 &#125; &#125; console.log("动画已执行进度", p); if(p &lt; 1.0)&#123; //如果小于1.0表示动画还诶有值完毕，继续执行动画。 requestAnimationFrame(change); &#125; &#125;);&#125; 常见动画效果实现 匀速运动 s = s * p; 匀加速运动s = s p p 匀减速运动s = s p (2 - p) 水平抛物x : s = s py : s = s p * p 正弦曲线运动x : s p 2y : Math.sin(2 Math.PI p) * s 圆周运动x = R Math.sin(2 π p)y = R Math.cos(2 π p) 动画算子动画算子是一个函数，可以把进度转化成另外一个值。常用的动画算子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var pow = Math.pow, BACK_CONST = 1.70158;// t指的的是动画进度 前面的pEasing = &#123; // 匀速运动 linear: function (t) &#123; return t; &#125;, // 加速运动 easeIn: function (t) &#123; return t * t; &#125;, // 减速运动 easeOut: function (t) &#123; return (2 - t) * t; &#125;, //先加速后减速 easeBoth: function (t) &#123; return (t *= 2) &lt; 1 ? .5 * t * t : .5 * (1 - (--t) * (t - 2)); &#125;, // 4次方加速 easeInStrong: function (t) &#123; return t * t * t * t; &#125;, // 4次方法的减速 easeOutStrong: function (t) &#123; return 1 - (--t) * t * t * t; &#125;, // 先加速后减速，加速和减速的都比较剧烈 easeBothStrong: function (t) &#123; return (t *= 2) &lt; 1 ? .5 * t * t * t * t : .5 * (2 - (t -= 2) * t * t * t); &#125;, // easeOutQuart: function (t) &#123; return -(Math.pow((t - 1), 4) - 1) &#125;, // 指数变化 加减速 easeInOutExpo: function (t) &#123; if (t === 0) return 0; if (t === 1) return 1; if ((t /= 0.5) &lt; 1) return 0.5 *Math.pow(2, 10 * (t - 1)); return 0.5 * (-Math.pow(2, - 10 * --t) + 2); &#125;, //指数式减速 easeOutExpo: function (t) &#123; return (t === 1) ? 1 : -Math.pow(2, - 10 * t) + 1; &#125;, // 先回弹，再加速 swingFrom: function (t) &#123; return t * t * ((BACK_CONST + 1) * t - BACK_CONST); &#125;, // 多走一段，再慢慢的回弹 swingTo: function (t) &#123; return (t -= 1) * t * ((BACK_CONST + 1) * t + BACK_CONST) + 1; &#125;, //弹跳 bounce: function (t) &#123; var s = 7.5625, r; if (t &lt; (1 / 2.75)) &#123; r = s * t * t; &#125; else if (t &lt; (2 / 2.75)) &#123; r = s * (t -= (1.5 / 2.75)) * t + .75; &#125; else if (t &lt; (2.5 / 2.75)) &#123; r = s * (t -= (2.25 / 2.75)) * t + .9375; &#125; else &#123; r = s * (t -= (2.625 / 2.75)) * t + .984375; &#125; return r; &#125; &#125;; 使用面向对象封装动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script type="text/javascript"&gt; /* 参数1：动画的执行时间 参数2：动画执行的时候的回调函数（动画执行的要干的事情） 参数3：动画算子. 如果没有传入动画算子，则默认使用匀速算子 */ function Animator(duration, progress, easing) &#123; this.duration = duration; this.progress = progress; this.easing = easing || function(p) &#123; return p &#125;; &#125; Animator.prototype = &#123; /*开始动画的方法， 参数：一个布尔值 true表示动画不循环执行。 */ start: function(finished) &#123; /*动画开始时间*/ var startTime = Date.now(); /*动画执行时间*/ var duration = this.duration, self = this; /*定义动画执行函数*/ requestAnimationFrame(function step() &#123; /*得到动画执行进度*/ var p = (Date.now() - startTime) / duration; /*是否执行下一帧动画*/ var next = true; /*判断动画进度是否完成*/ if(p &lt; 1.0) &#123; self.progress(self.easing(p), p); //执行动画回调函数，并传入动画算子的结果和动画进度。 &#125; else &#123; if(finished)&#123; //判断是否停止动画。如果是true代表停止动画。 next = false; &#125;else&#123; startTime = Date.now(); &#125; &#125; // 如果next是true执行下一帧动画 if(next) requestAnimationFrame(step); &#125;); &#125; &#125;; block.onclick = function () &#123; var self = this; new Animator(2000, function (p) &#123; self.style.top = 500 * p +"px"; &#125;,Easing.bounce).start(false); &#125; 逐帧动画逐帧动画主要用到 css雪碧图 和 setInterval() 组件和案例 瀑布流瀑布流的原理说起来很简单 主要就是判断用户滚动页面到最下方的时候自动添加内容，使得页面好像瀑布一样，落不到底。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script type="text/javascript"&gt; // 动态创建li标签，并向高度最低的ul中添加标签 // 工具函数：产生指定范围内的随机数 function randomFun (min, max) &#123; return parseInt(Math.random() * (max - min + 1) + min); &#125; window.onload = function () &#123; // 获取ul标签 var uls = document.getElementsByTagName('ul'); var num = 1; // 保存当前创建的是第几个li // 调用创建、拼接li的函数，把瀑布流图片加载出来 createLi(); // 当用户滚动页面时，判断用户卷起来的高度是否等于最大卷起来的高度，如果相等，则代表用户已经滚动到页面的底部，调用一次createLi,加载新标签 window.onscroll = function () &#123; // 获取到允许用户卷起来的最大高度 var maxHeight = document.documentElement.offsetHeight - document.documentElement.clientHeight; // 获取当前用户已经卷起来的高度 var height = document.body.scrollTop; // 判断用户卷起来的高度是否等于准许用户卷起来的总高 if (height &gt;= maxHeight-20) &#123;// console.log('已经到页面底部啦'); createLi(); &#125; &#125; // 封装创建li并拼接进文档流的操作 function createLi () &#123; // 创建li：一次创建30 for (var i = 0; i &lt; 30; i ++) &#123; var li = document.createElement('li'); // 给li添加样式 li.style.background = 'gray'; li.style.width = '200px'; li.style.height = randomFun(100, 300) + 'px'; li.innerText = num; num++; // li.style.marginTop = '10px'; // 找出高度最低的ul，把li拼接进去 // 1、定义一个变量，用来盛放高度最低的ul标签 var minHeight = uls[0]; // 2、定义一个变量，用来盛放高度最低标签的下标// var index = 0; // 3、通过for循环遍历数组，并判断出高度最低的标签 for (var j = 0; j &lt; uls.length; j++) &#123; if (minHeight.offsetHeight &gt; uls[j].offsetHeight) &#123; // 把当前判断出的新最小高度的标签放进minHeight变量中，用于下一次的判断 minHeight = uls[j]; // 保存当前最小高度标签的下标，供以后拼接li时使用// index = j; &#125; &#125; minHeight.appendChild(li); // 经过遍历比较后，把li拼接进高度最小的ul中// uls[index].appendChild(li); &#125; &#125; &#125; &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
